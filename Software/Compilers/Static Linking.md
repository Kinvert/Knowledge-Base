# Static Linking ğŸ§±

Static Linking is the process of combining all code and dependencies into a single self-contained executable at build time. Unlike [[Dynamic Linking]], where shared libraries (`.so`, `.dll`, `.dylib`) are loaded at runtime, static linking embeds every required symbol directly into the final binary. This approach produces larger executables but simplifies deployment, making it popular for embedded systems, robotics applications, and highly controlled runtime environments.

---
## âš™ï¸ Overview
In static linking, the linker (`ld`, `lld`, or `gold`) merges object files (`.o`) and static libraries (`.a`) into one executable. It copies only the symbols and sections actually needed by the program, removing unreferenced code. Because everything is resolved at build time, the resulting binary doesnâ€™t rely on external shared libraries during execution.

Common example:  
- **Input:** `main.o`, `libmath.a`, `librobot.a`  
- **Output:** `robot_controller` (standalone ELF executable)

---
## ğŸ§  Core Concepts
- **Object Files (`.o`)** â€” Compiled translation units generated by compilers.
- **Static Libraries (`.a`)** â€” Archives of multiple `.o` files created using `ar` (e.g., `libm.a`, `libc.a`).
- **Linker (`ld`, `lld`, `zig ld`)** â€” Resolves symbols and relocations, merges code/data sections.
- **Symbol Resolution** â€” The linker matches unresolved symbols in object files with definitions in libraries.
- **Relocation** â€” Adjusts addresses within code and data sections for the final memory layout.
- **Dead Code Elimination** â€” Removes unused functions/data to minimize final binary size.
- **Build-time Binding** â€” All dependencies must be known and resolvable at link time.
- **No runtime loader dependency** â€” No `ld-linux.so` or `DT_NEEDED` entries.

---
## ğŸ§© How It Works (Simplified Flow)
1. Each source file (`.c`, `.cpp`, `.zig`) compiles to an object file (`.o`).
2. The linker combines these with `.a` libraries into a final executable.
3. All symbol references are resolved and relocated during linking.
4. The resulting ELF binary is self-contained â€” no `.so` dependencies or `DT_NEEDED` entries.

---
## ğŸ§® Comparison Chart â€” Static vs Dynamic Linking

| Feature | Static Linking | Dynamic Linking |
|---|---|---|
| Linking time | Compile-time | Runtime |
| File size | Larger | Smaller |
| Dependencies | None (fully self-contained) | Requires shared libs |
| Memory usage | Duplicated per process | Shared between processes |
| Update mechanism | Rebuild/relink | Replace `.so` |
| Startup time | Faster (no loader overhead) | Slightly slower |
| Portability | High (no runtime deps) | Depends on environment |
| Ideal for | Embedded, robotics firmware, cross-compiled binaries | Desktops, servers, plugin systems |

---
## ğŸ§¾ Comparison Chart â€” Language Handling

| Language | Default Linking | Static Linking Support | Common Use Cases |
|---|---|---|---|
| C / C++ | Usually dynamic | Excellent (`-static`, `.a`) | Embedded, OS kernels, minimal binaries |
| Zig | Configurable | Excellent (fully static or hybrid builds) | Cross-compiling for embedded Linux, portable CLI tools |
| Python | Dynamic (interpreter-based) | Rare (requires embedding CPython) | Frozen executables (`PyInstaller`) |
| Elixir (BEAM) | Dynamic (VM-based) | Limited (BEAM is dynamic) | NIFs can statically link C libs |

---
## ğŸ› ï¸ Developer Tools
- **Linkers:** `ld`, `lld`, `gold`, `zig ld`
- **Archiver:** `ar` (creates `.a` libraries)
- **Inspectors:** `readelf`, `objdump`, `nm`
- **Strip Tools:** `strip`, `objcopy --strip-debug`
- **Flags:**  
  - `gcc -static` â€” produce static ELF  
  - `zig build-exe --static` â€” Zig static build  
  - `ld -Bstatic` â€” force static linkage

---
## ğŸ§© Compatible Items
- ELF executables (with no `DT_NEEDED`)
- `.a` static libraries
- C/C++/Zig toolchains
- Linkers (`ld`, `lld`, `zig ld`)
- Cross-compilers (`aarch64-linux-musl-gcc`, etc.)
- Embedded Linux distros (e.g., Buildroot, Yocto)
- `musl`, `uClibc`, or statically-linked `glibc` builds

---
## ğŸ” Use Cases
- **Embedded Robotics Systems:** Where library versions and dependencies must be fixed.
- **Firmware / Controllers:** Ensures predictable runtime with no external dependencies.
- **Static Containers:** Portable binaries for CI/CD, robotics clusters, or air-gapped systems.
- **Cross-compilation:** Build once on host, run anywhere with matching ISA.
- **Security-sensitive environments:** Reduced attack surface (no dynamic linking injection).

---
## ğŸ’ª Strengths
- Fully self-contained binaries.
- Simplified deployment (no missing library issues).
- Predictable runtime behavior.
- Improved startup time.
- Easier debugging and reproducibility.
- Compatible with musl libc for small static executables.

---
## âš ï¸ Weaknesses
- Larger binaries (duplicated code across processes).
- Harder to update (must relink/redeploy for each patch).
- Limited flexibility (no plugin or hot-swapping support).
- Increased compile/link time.
- Licensing concerns (GPL vs LGPL libraries when statically linking).

---
## ğŸ§± Related Concepts / Notes
- - [[Dynamic Linking]] (runtime linking alternative)
- - [[ELF]] (binary format used for both static and dynamic)
- - [[Shared Libraries]] (`.so` vs `.a`)
- - [[Linkers]] (ld, lld, gold)
- - [[Cross Compilation]] (producing self-contained binaries)
- - [[musl]] (lightweight static libc)
- - [[Zig]] (can produce fully static binaries)
- - [[ABI]] (symbol resolution and binary interface)
- - [[RPATH vs RUNPATH]] (irrelevant for static linking)
- - [[LD_PRELOAD]] (dynamic override, not applicable here)

---
## ğŸ“š External Resources
- *Ulrich Drepper*: â€œHow To Write Shared Librariesâ€ (Sections on static linking)
- GNU `ld` and `ar` man pages
- Zig documentation: `zig build-exe --static`
- `musl` libc documentation
- Linux man pages: `ld(1)`, `ar(1)`, `nm(1)`, `readelf(1)`

---
## ğŸ§© Summary
Static linking builds a single, monolithic executable containing all needed symbols, libraries, and code. It offers reliability, predictability, and independence from system configurations â€” ideal for robotics, embedded systems, or safety-critical applications. While dynamic linking provides flexibility, static linking shines when control and portability are paramount.

---
## ğŸ’¡ Quick Commands
- Build static binary (C): `gcc -static main.c -o main`
- Build static Zig binary: `zig build-exe --static src/main.zig`
- Create static lib: `ar rcs librobot.a robot.o sensor.o`
- Inspect binary: `readelf -d main` (should show â€œno dynamic sectionâ€)
- Strip debug info: `strip main`
